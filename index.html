<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Prévia • Background de Orbs</title>
  <style>
    :root {
      --bg: #0b0f14;
      --fg: #e9f1ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: #0a0c10;
      color: var(--fg);
      min-height: 100svh;
      display: grid;
      place-items: center;
      padding: 24px;
    }

    .meu-bloco {
      position: relative;
      width: min(1100px, 100%);
      min-height: 440px;
      background: var(--bg);
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
      isolation: isolate;
    }

    .conteudo {
      position: relative;
      z-index: 1;
      padding: clamp(20px, 4vw, 56px);
    }
    .conteudo h1 {
      margin: 0 0 10px;
      font-size: clamp(28px, 4vw, 44px);
      letter-spacing: -0.02em;
    }
    .conteudo p {
      max-width: 60ch;
      line-height: 1.6;
      opacity: .9;
      margin: 0 0 16px;
    }
    .row { display:flex; gap: 12px; flex-wrap: wrap; align-items:center; }
    .btn {
      appearance: none; border: 0; cursor: pointer; color: #0b0f14; background: #e9f1ff;
      padding: 10px 14px; border-radius: 12px; font-weight: 600;
      box-shadow: 0 2px 8px rgba(0,0,0,.3);
    }
    .btn:active { transform: translateY(1px); }
    .kbd { font: inherit; background: rgba(255,255,255,.08); padding: 6px 10px; border-radius: 10px; }

    .orb-bg { position: absolute; inset: 0; z-index: 0; pointer-events: none; }
    .orb { position: absolute; border-radius: 50%; opacity: .9; will-change: transform; filter: blur(0px);
           box-shadow: 0 0 24px rgba(255,255,255,.12); mix-blend-mode: screen; }

    @media (prefers-reduced-motion: reduce) {
      .orb { transition: none; animation: none; }
    }
  </style>
</head>
<body>
  <section class="meu-bloco">
    <div class="conteudo">
      <h1>Fundo de bolinhas animadas</h1>
      <p>Agora, além de se moverem, as orbs se afastam do mouse quando você passa por cima.</p>
      <div class="row">
        <button class="btn" id="toggleBtn">Pausar animação</button>
        <span class="kbd">Passe o mouse sobre o fundo para ver as orbs fugirem!</span>
      </div>
    </div>
    <div class="orb-bg" id="orb-bg"></div>
  </section>

  <script>
  (function () {
    const container = document.getElementById('orb-bg');
    if (!container) return;

    // Configurações
    const NUM = 20;
    const SIZE_MIN = 14;
    const SIZE_MAX = 80;
    const SPEED_MIN = 20;
    const SPEED_MAX = 80;
    const COLORS = [
      '#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#B983FF',
      '#F7AEF8','#FEC260','#00D1FF','#9B5DE5','#F15BB5',
      '#00F5D4','#C0FFEE','#FF9F1C','#2EC4B6','#E71D36',
      '#3A86FF','#8338EC','#FB5607','#FF006E','#8AC926'
    ];

    const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    const orbs = [];
    let bounds = getBounds();
    let paused = false;

    // posição do mouse
    let mouse = { x: -9999, y: -9999 };

    container.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    container.addEventListener('mouseleave', () => {
      mouse.x = -9999;
      mouse.y = -9999;
    });

    // Cria as orbs
    for (let i = 0; i < NUM; i++) {
      const el = document.createElement('div');
      el.className = 'orb';

      const size = rand(SIZE_MIN, SIZE_MAX);
      const color = COLORS[i % COLORS.length];

      const x = rand(0, Math.max(1, bounds.w - size));
      const y = rand(0, Math.max(1, bounds.h - size));

      const speed = rand(SPEED_MIN, SPEED_MAX);
      const angle = rand(0, Math.PI * 2);
      let vx = Math.cos(angle) * speed;
      let vy = Math.sin(angle) * speed;

      el.style.width = size + 'px';
      el.style.height = size + 'px';
      el.style.background = color;
      el.style.opacity = (0.7 + Math.random() * 0.3).toFixed(2);

      container.appendChild(el);
      orbs.push({ el, size, x, y, vx, vy });
    }

    let last = performance.now();
    function frame(now) {
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;

      if (!reduceMotion && !paused) {
        for (const orb of orbs) {
          // movimento normal
          orb.x += orb.vx * dt;
          orb.y += orb.vy * dt;

          // interação com o mouse
          const dx = orb.x + orb.size/2 - mouse.x;
          const dy = orb.y + orb.size/2 - mouse.y;
          const distSq = dx*dx + dy*dy;
          const influenceRadius = 120;
          if (distSq < influenceRadius*influenceRadius) {
            const dist = Math.sqrt(distSq) || 1;
            const force = (influenceRadius - dist) / influenceRadius * 200; // intensidade
            orb.vx += (dx/dist) * force * dt;
            orb.vy += (dy/dist) * force * dt;
          }

          // colisão com paredes
          if (orb.x <= 0) { orb.x = 0; orb.vx = Math.abs(orb.vx); }
          if (orb.y <= 0) { orb.y = 0; orb.vy = Math.abs(orb.vy); }
          if (orb.x + orb.size >= bounds.w) { orb.x = bounds.w - orb.size; orb.vx = -Math.abs(orb.vx); }
          if (orb.y + orb.size >= bounds.h) { orb.y = bounds.h - orb.size; orb.vy = -Math.abs(orb.vy); }

          orb.el.style.transform = `translate(${orb.x}px, ${orb.y}px)`;
        }
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    let resizeId;
    const ro = new ResizeObserver(() => {
      clearTimeout(resizeId);
      resizeId = setTimeout(() => {
        bounds = getBounds();
        for (const orb of orbs) {
          if (orb.x + orb.size > bounds.w) orb.x = Math.max(0, bounds.w - orb.size);
          if (orb.y + orb.size > bounds.h) orb.y = Math.max(0, bounds.h - orb.size);
        }
      }, 60);
    });
    ro.observe(container);

    const btn = document.getElementById('toggleBtn');
    btn?.addEventListener('click', () => {
      paused = !paused;
      btn.textContent = paused ? 'Retomar animação' : 'Pausar animação';
    });

    function getBounds() {
      const rect = container.getBoundingClientRect();
      return { w: rect.width, h: rect.height };
    }
    function rand(min, max) { return Math.random() * (max - min) + min; }
  })();
  </script>
</body>
</html>
